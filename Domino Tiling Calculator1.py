# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xG2iZ0BlEebEWJn-4ZhiDLJ0Y4W_dBeK
"""

import numpy as np
from collections import OrderedDict

# --- 1. Constants and Data Definition ---
# 4x4 Natural Square (Matrix containing numbers 1 to 16)
NATURAL_SQUARE = np.array([
    [ 1,  2,  3,  4],
    [ 5,  6,  7,  8],
    [ 9, 10, 11, 12],
    [13, 14, 15, 16]
])

# 36 Tiling Patterns (Defined by domino block labels)
PATTERNS_RAW = """
A A B B C C D D E E F F G G H H
A A B B C C D D E E F G H H F G
A A B B C C D D E F F G E H H G
A A B B C C D D E F G G E F H H
A A B B C C D D E F G H E F G H
A A B B C C D E F F D E G G H H
A A B B C C D E F G D E F G H H
A A B B C D D E C F F E G G H H
A A B B C D E E C D F F G G H H
A A B B C D E E C D F G H H F G
A A B B C D E F C D E F G G H H
A A B C D D B C E E F F G G H H
A A B C D D B C E E F G H H F G
A A B C D D B C E F F G E H H G
A A B C D D B C E F G G E F H H
A A B C D D B C E F G H E F G H
A A B C D E B C D E F F G G H H
A A B C D E B C D E F G H H F G
A B B C A D D C E E F F G G H H
A B B C A D D C E E F G H H F G
A B B C A D D C E F F G E H H G
A B B C A D D C E F G G E F H H
A B B C A D D C E F G H E F G H
A B B C A D E C F D E G F H H G
A B C C A B D D E E F F G G H H
A B C C A B D D E E F G H H F G
A B C C A B D D E F F G E H H G
A B C C A B D D E F G G E F H H
A B C C A B D D E F G H E F G H
A B C C A B D E F F D E G G H H
A B C C A B D E F G D E F G H H
A B C D A B C D E E F F G G H H
A B C D A B C D E E F G H H F G
A B C D A B C D E F F G E H H G
A B C D A B C D E F G G E F H H
A B C D A B C D E F G H E F G H
"""

# Generate Pattern Dictionary (OrderedDict to maintain order)
PATTERNS = OrderedDict()
pattern_index = 1
for line in PATTERNS_RAW.strip().split('\n'):
    cleaned_line = "".join(line.split())
    if len(cleaned_line) == 16:
        PATTERNS[pattern_index] = cleaned_line
        pattern_index += 1

# Target Invariant Sum (Constant C)
TARGET_SUM = 1428

# --- 2. Core Functions ---

def parse_pattern_to_domino_values(grid_labels):
    """Extracts domino value pairs [(x, y), ...] from pattern labels."""
    domino_blocks = {}
    for i in range(4):
        for j in range(4):
            label = grid_labels[i, j]
            value = NATURAL_SQUARE[i, j]
            if label not in domino_blocks:
                domino_blocks[label] = []
            domino_blocks[label].append(value)
    domino_values = []
    for values in domino_blocks.values():
        if len(values) != 2:
            raise ValueError(f"Tiling error: Block size is {len(values)} instead of 2.")
        domino_values.append(tuple(values))
    return domino_values

def calculate_s_prod(domino_values):
    """Calculates the 2-Block Product Sum: S_prod(P) = Sum (x_i * y_i)"""
    return sum(x * y for x, y in domino_values)

def get_rotated_pattern_str(pattern_str, degrees):
    """Rotates the pattern string clockwise by the specified degrees."""
    grid_labels = np.array(list(pattern_str)).reshape((4, 4))
    k = degrees // 90
    # k=-k ensures clockwise rotation
    rotated_labels = np.rot90(grid_labels, k=-k)
    return "".join(rotated_labels.flatten())

def normalize_pattern_str(pattern_str):
    """Normalizes the pattern string by relabeling the blocks sequentially (A, B, C...)."""
    grid = list(pattern_str)

    # Get unique old labels in order of first appearance
    unique_old_labels = []
    for label in grid:
        if label not in unique_old_labels:
            unique_old_labels.append(label)

    # Map old labels to new, normalized labels (A, B, C, ...)
    new_labels = [chr(ord('A') + i) for i in range(len(unique_old_labels))]
    label_map = {old: new for old, new in zip(unique_old_labels, new_labels)}

    # Generate the normalized pattern string
    normalized_grid = [label_map[old_label] for old_label in grid]
    return "".join(normalized_grid)

def find_rotated_pair_id(P_rot_str):
    """Normalizes the rotated pattern string and finds the matching P_id."""
    P_rot_normalized = normalize_pattern_str(P_rot_str)

    # Compare with all pre-defined patterns
    for pid, pattern_str in PATTERNS.items():
        if pattern_str == P_rot_normalized:
            return f"P{pid}"

    return 'N/A (Error)'

# --- 3. Verification Execution and Result Integration ---

def verify_rotation_identity(degrees):
    results = []
    invariant_count = 0
    total_patterns = len(PATTERNS)

    for pid, pattern_str in PATTERNS.items():
        try:
            P_labels = np.array(list(pattern_str)).reshape((4, 4))
            S_prod_P = calculate_s_prod(parse_pattern_to_domino_values(P_labels))

            P_rot_str = get_rotated_pattern_str(pattern_str, degrees)
            P_rot_labels = np.array(list(P_rot_str)).reshape((4, 4))
            S_prod_P_rot = calculate_s_prod(parse_pattern_to_domino_values(P_rot_labels))

            P_rot_id = find_rotated_pair_id(P_rot_str)

            total_sum = S_prod_P + S_prod_P_rot
            is_invariant = (total_sum == TARGET_SUM)

            if is_invariant:
                invariant_count += 1
                check_symbol = '$\checkmark$'
            else:
                check_symbol = f'FAIL ({total_sum})'

            results.append({
                'P_i': f"P{pid}",
                'S_prod_P': S_prod_P,
                'P_j': P_rot_id,
                'S_prod_P_rot': S_prod_P_rot,
                'Sum': total_sum,
                'Check': check_symbol,
            })

        except ValueError as e:
            results.append({
                'P_i': f"P{pid}", 'S_prod_P': 'Error', 'P_j': 'Error',
                'S_prod_P_rot': 'Error', 'Sum': 'Error', 'Check': f'Error: {e}'
            })

    return results, invariant_count, total_patterns

# --- 4. LaTeX Output Function ---

def generate_latex_table(results, degrees, invariant_count, total_patterns):

    latex_code = "\\begin{table}[H]\n"
    latex_code += "\\centering\n"
    latex_code += f"\\caption{{Verification of ${degrees}^\\circ$ Rotation Product Sum Identity for All {total_patterns} Tilings}}\n"
    latex_code += f"\\label{{tab:{degrees}-degree-check}}\n"
    latex_code += "\\begin{tabular}{cccccc}\n"
    latex_code += "\\toprule\n"
    latex_code += f"$P_i$ & $S_{{\\text{{prod}}}}(P_i)$ & Rotated Pair ($P_j = P_i^{{{degrees}}}$) & $S_{{\\text{{prod}}}}(P_j)$ & Total Sum & Match \\\\\n"
    latex_code += "\\midrule\n"

    for res in results:
        # P_j (Rotated Pair ID) check
        P_j_display = res['P_j'] if 'Error' not in res['P_j'] else 'N/A'

        latex_code += (
            f"{res['P_i']} & {res['S_prod_P']} & {P_j_display} & {res['S_prod_P_rot']} & {res['Sum']} & {res['Check']} \\\\\n"
        )

    latex_code += "\\bottomrule\n"

    if invariant_count == total_patterns:
        note = f"\\multicolumn{{6}}{{l}}{{\\footnotesize Note: The identity $S_{{\\text{{prod}}}}(P_i) + S_{{\\text{{prod}}}}(P_i^{{{degrees}}}) = {TARGET_SUM}$ holds for all $i=1, \\dots, {total_patterns}$.}}\n"
    else:
        note = f"\\multicolumn{{6}}{{l}}{{\\footnotesize Note: The identity held for {invariant_count} out of {total_patterns} patterns.}}\n"

    latex_code += note
    latex_code += "\\end{tabular}\n"
    latex_code += "\\end{table}\n"

    return latex_code

# --- 5. Execution ---

if __name__ == "__main__":

    # Execute 90-degree rotation verification
    rotation_degrees = 90
    results_90, count_90, total_90 = verify_rotation_identity(rotation_degrees)

    # Generate and print LaTeX code
    latex_output = generate_latex_table(results_90, rotation_degrees, count_90, total_90)

    print("## âœ… 90-Degree Rotation Product Sum Identity Verification Results (LaTeX Format)\n")
    print(latex_output)

    # Print a plain text summary for confirmation
    print("\n--- Summary ---")
    print(f"Identity holds for: {count_90}/{total_90}")